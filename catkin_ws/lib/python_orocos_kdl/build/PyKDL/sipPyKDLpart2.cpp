/*
 * Module code.
 *
 * Generated by SIP 4.17
 */

#include "sipAPIPyKDL.h"

#line 529 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolvervel_pinv_nso.hpp>
using namespace KDL;
#line 13 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"

#line 133 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 18 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"
#line 172 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 22 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"
#line 281 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 28 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"


class sipChainIkSolverVel_pinv_nso : public ChainIkSolverVel_pinv_nso
{
public:
    sipChainIkSolverVel_pinv_nso(const Chain&,double,int,double);
    sipChainIkSolverVel_pinv_nso(const ChainIkSolverVel_pinv_nso&);
    virtual ~sipChainIkSolverVel_pinv_nso();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    int setAlpha(const double);
    int setOptPos(const JntArray&);
    int setWeights(const JntArray&);
    void updateInternalDataStructures();
    int CartToJnt(const JntArray&,const Twist&,JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverVel_pinv_nso(const sipChainIkSolverVel_pinv_nso &);
    sipChainIkSolverVel_pinv_nso &operator = (const sipChainIkSolverVel_pinv_nso &);

    char sipPyMethods[5];
};

sipChainIkSolverVel_pinv_nso::sipChainIkSolverVel_pinv_nso(const Chain& a0,double a1,int a2,double a3): ChainIkSolverVel_pinv_nso(a0,a1,a2,a3), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv_nso::sipChainIkSolverVel_pinv_nso(const ChainIkSolverVel_pinv_nso& a0): ChainIkSolverVel_pinv_nso(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv_nso::~sipChainIkSolverVel_pinv_nso()
{
    sipCommonDtor(sipPySelf);
}

int sipChainIkSolverVel_pinv_nso::setAlpha(const double a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_setAlpha);

    if (!sipMeth)
        return ChainIkSolverVel_pinv_nso::setAlpha(a0);

    extern int sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const double);

    return sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth, a0);
}

int sipChainIkSolverVel_pinv_nso::setOptPos(const JntArray& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_setOptPos);

    if (!sipMeth)
        return ChainIkSolverVel_pinv_nso::setOptPos(a0);

    extern int sipVH_PyKDL_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const JntArray&);

    return sipVH_PyKDL_3(sipGILState, 0, sipPySelf, sipMeth, a0);
}

int sipChainIkSolverVel_pinv_nso::setWeights(const JntArray& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,NULL,sipName_setWeights);

    if (!sipMeth)
        return ChainIkSolverVel_pinv_nso::setWeights(a0);

    extern int sipVH_PyKDL_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const JntArray&);

    return sipVH_PyKDL_3(sipGILState, 0, sipPySelf, sipMeth, a0);
}

void sipChainIkSolverVel_pinv_nso::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
        ChainIkSolverVel_pinv_nso::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_0(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverVel_pinv_nso::CartToJnt(const JntArray& a0,const Twist& a1,JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return ChainIkSolverVel_pinv_nso::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const JntArray&,const Twist&,JntArray&);

    return sipVH_PyKDL_1(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_CartToJnt, "ChainIkSolverVel_pinv_nso.CartToJnt(JntArray, Twist, JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        const JntArray* a0;
        const Twist* a1;
        JntArray* a2;
        ChainIkSolverVel_pinv_nso *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_v_in,
            sipName_qdot_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp, sipType_JntArray, &a0, sipType_Twist, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp->ChainIkSolverVel_pinv_nso::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_CartToJnt, doc_ChainIkSolverVel_pinv_nso_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_updateInternalDataStructures, "ChainIkSolverVel_pinv_nso.updateInternalDataStructures()");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        ChainIkSolverVel_pinv_nso *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp->ChainIkSolverVel_pinv_nso::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_updateInternalDataStructures, doc_ChainIkSolverVel_pinv_nso_updateInternalDataStructures);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_setWeights, "ChainIkSolverVel_pinv_nso.setWeights(JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_setWeights(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_setWeights(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        const JntArray* a0;
        ChainIkSolverVel_pinv_nso *sipCpp;

        static const char *sipKwdList[] = {
            sipName_weights,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp, sipType_JntArray, &a0))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp->ChainIkSolverVel_pinv_nso::setWeights(*a0) : sipCpp->setWeights(*a0));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_setWeights, doc_ChainIkSolverVel_pinv_nso_setWeights);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_setOptPos, "ChainIkSolverVel_pinv_nso.setOptPos(JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_setOptPos(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_setOptPos(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        const JntArray* a0;
        ChainIkSolverVel_pinv_nso *sipCpp;

        static const char *sipKwdList[] = {
            sipName_opt_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp, sipType_JntArray, &a0))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp->ChainIkSolverVel_pinv_nso::setOptPos(*a0) : sipCpp->setOptPos(*a0));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_setOptPos, doc_ChainIkSolverVel_pinv_nso_setOptPos);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_setAlpha, "ChainIkSolverVel_pinv_nso.setAlpha(float) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_setAlpha(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_setAlpha(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        double a0;
        ChainIkSolverVel_pinv_nso *sipCpp;

        static const char *sipKwdList[] = {
            sipName_alpha,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp, &a0))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp->ChainIkSolverVel_pinv_nso::setAlpha(a0) : sipCpp->setAlpha(a0));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_setAlpha, doc_ChainIkSolverVel_pinv_nso_setAlpha);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_getWeights, "ChainIkSolverVel_pinv_nso.getWeights() -> JntArray");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_getWeights(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_getWeights(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const ChainIkSolverVel_pinv_nso *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp))
        {
            JntArray*sipRes;

            sipRes = new JntArray(sipCpp->getWeights());

            return sipConvertFromNewType(sipRes,sipType_JntArray,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_getWeights, doc_ChainIkSolverVel_pinv_nso_getWeights);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_getOptPos, "ChainIkSolverVel_pinv_nso.getOptPos() -> JntArray");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_getOptPos(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_getOptPos(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const ChainIkSolverVel_pinv_nso *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp))
        {
            JntArray*sipRes;

            sipRes = new JntArray(sipCpp->getOptPos());

            return sipConvertFromNewType(sipRes,sipType_JntArray,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_getOptPos, doc_ChainIkSolverVel_pinv_nso_getOptPos);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_getAlpha, "ChainIkSolverVel_pinv_nso.getAlpha() -> float");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_getAlpha(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_getAlpha(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const ChainIkSolverVel_pinv_nso *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp))
        {
            double sipRes;

            sipRes = sipCpp->getAlpha();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_getAlpha, doc_ChainIkSolverVel_pinv_nso_getAlpha);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_ChainIkSolverVel_pinv_nso(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverVel_pinv_nso(void *ptr, const sipTypeDef *targetType)
{
    void *res;

    if (targetType == sipType_ChainIkSolverVel_pinv_nso)
        return ptr;

    if ((res = ((const sipClassTypeDef *)sipType_ChainIkSolverVel)->ctd_cast((ChainIkSolverVel *)(ChainIkSolverVel_pinv_nso *)ptr,targetType)) != NULL)
        return res;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverVel_pinv_nso(void *, int);}
static void release_ChainIkSolverVel_pinv_nso(void *sipCppV,int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverVel_pinv_nso *>(sipCppV);
    else
        delete reinterpret_cast<ChainIkSolverVel_pinv_nso *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverVel_pinv_nso(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverVel_pinv_nso(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerived(sipSelf))
        reinterpret_cast<sipChainIkSolverVel_pinv_nso *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsPyOwned(sipSelf))
    {
        release_ChainIkSolverVel_pinv_nso(sipGetAddress(sipSelf),sipSelf->flags);
    }
}


extern "C" {static void *init_type_ChainIkSolverVel_pinv_nso(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverVel_pinv_nso(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverVel_pinv_nso *sipCpp = 0;

    {
        const Chain* a0;
        double a1 = 1e-05;
        int a2 = 150;
        double a3 = 0.25;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_eps,
            sipName_maxiter,
            sipName_alpha,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|did", sipType_Chain, &a0, &a1, &a2, &a3))
        {
            sipCpp = new sipChainIkSolverVel_pinv_nso(*a0,a1,a2,a3);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const ChainIkSolverVel_pinv_nso* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverVel_pinv_nso, &a0))
        {
            sipCpp = new sipChainIkSolverVel_pinv_nso(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverVel_pinv_nso[] = {{10, 255, 1}};


static PyMethodDef methods_ChainIkSolverVel_pinv_nso[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverVel_pinv_nso_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_getAlpha), meth_ChainIkSolverVel_pinv_nso_getAlpha, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_getAlpha)},
    {SIP_MLNAME_CAST(sipName_getOptPos), meth_ChainIkSolverVel_pinv_nso_getOptPos, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_getOptPos)},
    {SIP_MLNAME_CAST(sipName_getWeights), meth_ChainIkSolverVel_pinv_nso_getWeights, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_getWeights)},
    {SIP_MLNAME_CAST(sipName_setAlpha), (PyCFunction)meth_ChainIkSolverVel_pinv_nso_setAlpha, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_setAlpha)},
    {SIP_MLNAME_CAST(sipName_setOptPos), (PyCFunction)meth_ChainIkSolverVel_pinv_nso_setOptPos, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_setOptPos)},
    {SIP_MLNAME_CAST(sipName_setWeights), (PyCFunction)meth_ChainIkSolverVel_pinv_nso_setWeights, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_setWeights)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverVel_pinv_nso_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso, "\1ChainIkSolverVel_pinv_nso(Chain, float eps=1e-05, int maxiter=150, float alpha=0.25)\n"
    "ChainIkSolverVel_pinv_nso(ChainIkSolverVel_pinv_nso)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverVel_pinv_nso = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverVel_pinv_nso,
        {0}
    },
    {
        sipNameNr_ChainIkSolverVel_pinv_nso,
        {0, 0, 1},
        8, methods_ChainIkSolverVel_pinv_nso,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverVel_pinv_nso,
    -1,
    -1,
    supers_ChainIkSolverVel_pinv_nso,
    0,
    init_type_ChainIkSolverVel_pinv_nso,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverVel_pinv_nso,
    0,
    0,
    0,
    release_ChainIkSolverVel_pinv_nso,
    cast_ChainIkSolverVel_pinv_nso,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 515 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolverpos_lma.hpp>
using namespace KDL;
#line 553 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"

#line 133 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 558 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"
#line 172 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 562 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"
#line 201 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 568 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"


class sipChainIkSolverPos_LMA : public ChainIkSolverPos_LMA
{
public:
    sipChainIkSolverPos_LMA(const Chain&,double,int,double);
    sipChainIkSolverPos_LMA(const ChainIkSolverPos_LMA&);
    virtual ~sipChainIkSolverPos_LMA();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const JntArray&,const Frame&,JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverPos_LMA(const sipChainIkSolverPos_LMA &);
    sipChainIkSolverPos_LMA &operator = (const sipChainIkSolverPos_LMA &);

    char sipPyMethods[2];
};

sipChainIkSolverPos_LMA::sipChainIkSolverPos_LMA(const Chain& a0,double a1,int a2,double a3): ChainIkSolverPos_LMA(a0,a1,a2,a3), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_LMA::sipChainIkSolverPos_LMA(const ChainIkSolverPos_LMA& a0): ChainIkSolverPos_LMA(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_LMA::~sipChainIkSolverPos_LMA()
{
    sipCommonDtor(sipPySelf);
}

void sipChainIkSolverPos_LMA::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
        ChainIkSolverPos_LMA::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_0(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverPos_LMA::CartToJnt(const JntArray& a0,const Frame& a1,JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return ChainIkSolverPos_LMA::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const JntArray&,const Frame&,JntArray&);

    return sipVH_PyKDL_4(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverPos_LMA_CartToJnt, "ChainIkSolverPos_LMA.CartToJnt(JntArray, Frame, JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverPos_LMA_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_LMA_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        const JntArray* a0;
        const Frame* a1;
        JntArray* a2;
        ChainIkSolverPos_LMA *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_init,
            sipName_p_in,
            sipName_q_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverPos_LMA, &sipCpp, sipType_JntArray, &a0, sipType_Frame, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp->ChainIkSolverPos_LMA::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_LMA, sipName_CartToJnt, doc_ChainIkSolverPos_LMA_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverPos_LMA_updateInternalDataStructures, "ChainIkSolverPos_LMA.updateInternalDataStructures()");

extern "C" {static PyObject *meth_ChainIkSolverPos_LMA_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_LMA_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        ChainIkSolverPos_LMA *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverPos_LMA, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp->ChainIkSolverPos_LMA::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_LMA, sipName_updateInternalDataStructures, doc_ChainIkSolverPos_LMA_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_ChainIkSolverPos_LMA(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverPos_LMA(void *ptr, const sipTypeDef *targetType)
{
    void *res;

    if (targetType == sipType_ChainIkSolverPos_LMA)
        return ptr;

    if ((res = ((const sipClassTypeDef *)sipType_ChainIkSolverPos)->ctd_cast((ChainIkSolverPos *)(ChainIkSolverPos_LMA *)ptr,targetType)) != NULL)
        return res;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverPos_LMA(void *, int);}
static void release_ChainIkSolverPos_LMA(void *sipCppV,int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverPos_LMA *>(sipCppV);
    else
        delete reinterpret_cast<ChainIkSolverPos_LMA *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverPos_LMA(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverPos_LMA(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerived(sipSelf))
        reinterpret_cast<sipChainIkSolverPos_LMA *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsPyOwned(sipSelf))
    {
        release_ChainIkSolverPos_LMA(sipGetAddress(sipSelf),sipSelf->flags);
    }
}


extern "C" {static void *init_type_ChainIkSolverPos_LMA(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverPos_LMA(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverPos_LMA *sipCpp = 0;

    {
        const Chain* a0;
        double a1 = 1e-05;
        int a2 = 500;
        double a3 = 1e-15;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_eps,
            sipName__maxiter,
            sipName__eps_joints,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|did", sipType_Chain, &a0, &a1, &a2, &a3))
        {
            sipCpp = new sipChainIkSolverPos_LMA(*a0,a1,a2,a3);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const ChainIkSolverPos_LMA* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverPos_LMA, &a0))
        {
            sipCpp = new sipChainIkSolverPos_LMA(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverPos_LMA[] = {{6, 255, 1}};


static PyMethodDef methods_ChainIkSolverPos_LMA[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverPos_LMA_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_LMA_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverPos_LMA_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_LMA_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverPos_LMA, "\1ChainIkSolverPos_LMA(Chain, float eps=1e-05, int _maxiter=500, float _eps_joints=1e-15)\n"
    "ChainIkSolverPos_LMA(ChainIkSolverPos_LMA)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverPos_LMA = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverPos_LMA,
        {0}
    },
    {
        sipNameNr_ChainIkSolverPos_LMA,
        {0, 0, 1},
        2, methods_ChainIkSolverPos_LMA,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverPos_LMA,
    -1,
    -1,
    supers_ChainIkSolverPos_LMA,
    0,
    init_type_ChainIkSolverPos_LMA,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverPos_LMA,
    0,
    0,
    0,
    release_ChainIkSolverPos_LMA,
    cast_ChainIkSolverPos_LMA,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 428 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolvervel_wdls.hpp>
using namespace KDL;
#line 859 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"

#line 133 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 864 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"
#line 172 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 868 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"
#line 281 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 874 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"


class sipChainIkSolverVel_wdls : public ChainIkSolverVel_wdls
{
public:
    sipChainIkSolverVel_wdls(const Chain&,double,int);
    sipChainIkSolverVel_wdls(const ChainIkSolverVel_wdls&);
    virtual ~sipChainIkSolverVel_wdls();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const JntArray&,const Twist&,JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverVel_wdls(const sipChainIkSolverVel_wdls &);
    sipChainIkSolverVel_wdls &operator = (const sipChainIkSolverVel_wdls &);

    char sipPyMethods[2];
};

sipChainIkSolverVel_wdls::sipChainIkSolverVel_wdls(const Chain& a0,double a1,int a2): ChainIkSolverVel_wdls(a0,a1,a2), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_wdls::sipChainIkSolverVel_wdls(const ChainIkSolverVel_wdls& a0): ChainIkSolverVel_wdls(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_wdls::~sipChainIkSolverVel_wdls()
{
    sipCommonDtor(sipPySelf);
}

void sipChainIkSolverVel_wdls::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
        ChainIkSolverVel_wdls::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_0(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverVel_wdls::CartToJnt(const JntArray& a0,const Twist& a1,JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return ChainIkSolverVel_wdls::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const JntArray&,const Twist&,JntArray&);

    return sipVH_PyKDL_1(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_CartToJnt, "ChainIkSolverVel_wdls.CartToJnt(JntArray, Twist, JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        const JntArray* a0;
        const Twist* a1;
        JntArray* a2;
        ChainIkSolverVel_wdls *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_v_in,
            sipName_qdot_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp, sipType_JntArray, &a0, sipType_Twist, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp->ChainIkSolverVel_wdls::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_CartToJnt, doc_ChainIkSolverVel_wdls_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_updateInternalDataStructures, "ChainIkSolverVel_wdls.updateInternalDataStructures()");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        ChainIkSolverVel_wdls *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp->ChainIkSolverVel_wdls::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_updateInternalDataStructures, doc_ChainIkSolverVel_wdls_updateInternalDataStructures);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_setWeightTS, "ChainIkSolverVel_wdls.setWeightTS(list)");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_setWeightTS(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_setWeightTS(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        ChainIkSolverVel_wdls *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BT", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp, &PyList_Type, &a0))
        {
            int sipIsErr = 0;

#line 439 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
    //void setWeightTS(const Eigen::MatrixXd& Mx);
    //Mx has to be a 6x6 Matrix

    Py_ssize_t numRows,numCols;
    double c_item;
    PyObject *list=a0;
    numRows=PyList_Size(list);
    PyObject *temp1;
    temp1=PyList_GetItem(list,0);
    numCols=PyList_Size(temp1);
    if (numRows!=numCols) {
       sipIsErr=1; //todo: raise exception
    }
    if (numRows!=6) {
       sipIsErr=1; //todo: raise exception
    }
    Eigen::MatrixXd Mx;
    Mx=Eigen::MatrixXd::Identity(numRows,numCols);
    
    for (Py_ssize_t r=0;r<numRows;r++) {
        PyObject *row;
        row=PyList_GetItem(list,r);
        if (numCols!=PyList_Size(row)) {
           sipIsErr=1; //todo: raise exception
        }
        for (Py_ssize_t c=0;c<numCols;c++) {
            PyObject *item;
            item=PyList_GetItem(row,c);
            c_item=PyFloat_AsDouble(item);
            Mx(r,c)= c_item;
        }
    }
    sipCpp->setWeightTS(Mx);
#line 1064 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_setWeightTS, doc_ChainIkSolverVel_wdls_setWeightTS);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_setWeightJS, "ChainIkSolverVel_wdls.setWeightJS(list)");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_setWeightJS(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_setWeightJS(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        ChainIkSolverVel_wdls *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BT", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp, &PyList_Type, &a0))
        {
            int sipIsErr = 0;

#line 476 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
    //void setWeightJS(const Eigen::MatrixXd& Mx);
    //Mx has to be a simetric positive definite Matrix
    //unsigned int nOfJoints=sipCpp->chain.getNrOfJoints(); //To check that we are receiving valid data dimensions. This doesn't work, chain is a private member. todo: How can we check for this?
    Py_ssize_t numRows,numCols;
    double c_item;
    PyObject *list=a0;
    numRows=PyList_Size(list);
    PyObject *temp1;
    temp1=PyList_GetItem(list,0);
    numCols=PyList_Size(temp1);
    if (numRows!=numCols) {
       sipIsErr=1; //todo: raise exception
    }
    Eigen::MatrixXd Mq;
    Mq=Eigen::MatrixXd::Identity(numRows,numCols);
    for (Py_ssize_t r=0;r<numRows;r++) {
        PyObject *row;
        row=PyList_GetItem(list,r);
        if (numCols!=PyList_Size(row)) {
           sipIsErr=1; //todo: raise exception
        }
        for (Py_ssize_t c=0;c<numCols;c++) {
            PyObject *item;
            item=PyList_GetItem(row,c);
            c_item=PyFloat_AsDouble(item);
            Mq(r,c)= c_item;
        }
    }
    sipCpp->setWeightJS(Mq);
#line 1126 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_setWeightJS, doc_ChainIkSolverVel_wdls_setWeightJS);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_setLambda, "ChainIkSolverVel_wdls.setLambda(float)");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_setLambda(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_setLambda(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        ChainIkSolverVel_wdls *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lambda,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp, &a0))
        {
            sipCpp->setLambda(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_setLambda, doc_ChainIkSolverVel_wdls_setLambda);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_ChainIkSolverVel_wdls(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverVel_wdls(void *ptr, const sipTypeDef *targetType)
{
    void *res;

    if (targetType == sipType_ChainIkSolverVel_wdls)
        return ptr;

    if ((res = ((const sipClassTypeDef *)sipType_ChainIkSolverVel)->ctd_cast((ChainIkSolverVel *)(ChainIkSolverVel_wdls *)ptr,targetType)) != NULL)
        return res;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverVel_wdls(void *, int);}
static void release_ChainIkSolverVel_wdls(void *sipCppV,int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverVel_wdls *>(sipCppV);
    else
        delete reinterpret_cast<ChainIkSolverVel_wdls *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverVel_wdls(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverVel_wdls(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerived(sipSelf))
        reinterpret_cast<sipChainIkSolverVel_wdls *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsPyOwned(sipSelf))
    {
        release_ChainIkSolverVel_wdls(sipGetAddress(sipSelf),sipSelf->flags);
    }
}


extern "C" {static void *init_type_ChainIkSolverVel_wdls(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverVel_wdls(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverVel_wdls *sipCpp = 0;

    {
        const Chain* a0;
        double a1 = 1e-05;
        int a2 = 150;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_eps,
            sipName_maxiter,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|di", sipType_Chain, &a0, &a1, &a2))
        {
            sipCpp = new sipChainIkSolverVel_wdls(*a0,a1,a2);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const ChainIkSolverVel_wdls* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverVel_wdls, &a0))
        {
            sipCpp = new sipChainIkSolverVel_wdls(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverVel_wdls[] = {{10, 255, 1}};


static PyMethodDef methods_ChainIkSolverVel_wdls[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverVel_wdls_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_setLambda), (PyCFunction)meth_ChainIkSolverVel_wdls_setLambda, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_setLambda)},
    {SIP_MLNAME_CAST(sipName_setWeightJS), meth_ChainIkSolverVel_wdls_setWeightJS, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_setWeightJS)},
    {SIP_MLNAME_CAST(sipName_setWeightTS), meth_ChainIkSolverVel_wdls_setWeightTS, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_setWeightTS)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverVel_wdls_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverVel_wdls, "\1ChainIkSolverVel_wdls(Chain, float eps=1e-05, int maxiter=150)\n"
    "ChainIkSolverVel_wdls(ChainIkSolverVel_wdls)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverVel_wdls = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverVel_wdls,
        {0}
    },
    {
        sipNameNr_ChainIkSolverVel_wdls,
        {0, 0, 1},
        5, methods_ChainIkSolverVel_wdls,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverVel_wdls,
    -1,
    -1,
    supers_ChainIkSolverVel_wdls,
    0,
    init_type_ChainIkSolverVel_wdls,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverVel_wdls,
    0,
    0,
    0,
    release_ChainIkSolverVel_wdls,
    cast_ChainIkSolverVel_wdls,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 415 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolvervel_pinv.hpp>
using namespace KDL;
#line 1325 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"

#line 133 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 1330 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"
#line 172 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 1334 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"
#line 281 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1340 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"


class sipChainIkSolverVel_pinv : public ChainIkSolverVel_pinv
{
public:
    sipChainIkSolverVel_pinv(const Chain&,double,int);
    sipChainIkSolverVel_pinv(const ChainIkSolverVel_pinv&);
    virtual ~sipChainIkSolverVel_pinv();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const JntArray&,const Twist&,JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverVel_pinv(const sipChainIkSolverVel_pinv &);
    sipChainIkSolverVel_pinv &operator = (const sipChainIkSolverVel_pinv &);

    char sipPyMethods[2];
};

sipChainIkSolverVel_pinv::sipChainIkSolverVel_pinv(const Chain& a0,double a1,int a2): ChainIkSolverVel_pinv(a0,a1,a2), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv::sipChainIkSolverVel_pinv(const ChainIkSolverVel_pinv& a0): ChainIkSolverVel_pinv(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv::~sipChainIkSolverVel_pinv()
{
    sipCommonDtor(sipPySelf);
}

void sipChainIkSolverVel_pinv::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
        ChainIkSolverVel_pinv::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_0(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverVel_pinv::CartToJnt(const JntArray& a0,const Twist& a1,JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return ChainIkSolverVel_pinv::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const JntArray&,const Twist&,JntArray&);

    return sipVH_PyKDL_1(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_CartToJnt, "ChainIkSolverVel_pinv.CartToJnt(JntArray, Twist, JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        const JntArray* a0;
        const Twist* a1;
        JntArray* a2;
        ChainIkSolverVel_pinv *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_v_in,
            sipName_qdot_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel_pinv, &sipCpp, sipType_JntArray, &a0, sipType_Twist, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp->ChainIkSolverVel_pinv::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv, sipName_CartToJnt, doc_ChainIkSolverVel_pinv_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_updateInternalDataStructures, "ChainIkSolverVel_pinv.updateInternalDataStructures()");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        ChainIkSolverVel_pinv *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp->ChainIkSolverVel_pinv::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv, sipName_updateInternalDataStructures, doc_ChainIkSolverVel_pinv_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_ChainIkSolverVel_pinv(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverVel_pinv(void *ptr, const sipTypeDef *targetType)
{
    void *res;

    if (targetType == sipType_ChainIkSolverVel_pinv)
        return ptr;

    if ((res = ((const sipClassTypeDef *)sipType_ChainIkSolverVel)->ctd_cast((ChainIkSolverVel *)(ChainIkSolverVel_pinv *)ptr,targetType)) != NULL)
        return res;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverVel_pinv(void *, int);}
static void release_ChainIkSolverVel_pinv(void *sipCppV,int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverVel_pinv *>(sipCppV);
    else
        delete reinterpret_cast<ChainIkSolverVel_pinv *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverVel_pinv(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverVel_pinv(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerived(sipSelf))
        reinterpret_cast<sipChainIkSolverVel_pinv *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsPyOwned(sipSelf))
    {
        release_ChainIkSolverVel_pinv(sipGetAddress(sipSelf),sipSelf->flags);
    }
}


extern "C" {static void *init_type_ChainIkSolverVel_pinv(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverVel_pinv(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverVel_pinv *sipCpp = 0;

    {
        const Chain* a0;
        double a1 = 1e-05;
        int a2 = 150;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_eps,
            sipName_maxiter,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|di", sipType_Chain, &a0, &a1, &a2))
        {
            sipCpp = new sipChainIkSolverVel_pinv(*a0,a1,a2);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const ChainIkSolverVel_pinv* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverVel_pinv, &a0))
        {
            sipCpp = new sipChainIkSolverVel_pinv(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverVel_pinv[] = {{10, 255, 1}};


static PyMethodDef methods_ChainIkSolverVel_pinv[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverVel_pinv_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverVel_pinv_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverVel_pinv, "\1ChainIkSolverVel_pinv(Chain, float eps=1e-05, int maxiter=150)\n"
    "ChainIkSolverVel_pinv(ChainIkSolverVel_pinv)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverVel_pinv = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverVel_pinv,
        {0}
    },
    {
        sipNameNr_ChainIkSolverVel_pinv,
        {0, 0, 1},
        2, methods_ChainIkSolverVel_pinv,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverVel_pinv,
    -1,
    -1,
    supers_ChainIkSolverVel_pinv,
    0,
    init_type_ChainIkSolverVel_pinv,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverVel_pinv,
    0,
    0,
    0,
    release_ChainIkSolverVel_pinv,
    cast_ChainIkSolverVel_pinv,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 400 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolverpos_nr_jl.hpp>
using namespace KDL;
#line 1629 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"

#line 133 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 1634 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"
#line 172 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 1638 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"
#line 320 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainfksolver.hpp>
using namespace KDL;
#line 1642 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"
#line 374 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolver.hpp>
using namespace KDL;
#line 1646 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"
#line 201 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1652 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart2.cpp"


class sipChainIkSolverPos_NR_JL : public ChainIkSolverPos_NR_JL
{
public:
    sipChainIkSolverPos_NR_JL(const Chain&,const JntArray&,const JntArray&,ChainFkSolverPos&,ChainIkSolverVel&,uint,double);
    sipChainIkSolverPos_NR_JL(const ChainIkSolverPos_NR_JL&);
    virtual ~sipChainIkSolverPos_NR_JL();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const JntArray&,const Frame&,JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverPos_NR_JL(const sipChainIkSolverPos_NR_JL &);
    sipChainIkSolverPos_NR_JL &operator = (const sipChainIkSolverPos_NR_JL &);

    char sipPyMethods[2];
};

sipChainIkSolverPos_NR_JL::sipChainIkSolverPos_NR_JL(const Chain& a0,const JntArray& a1,const JntArray& a2,ChainFkSolverPos& a3,ChainIkSolverVel& a4,uint a5,double a6): ChainIkSolverPos_NR_JL(a0,a1,a2,a3,a4,a5,a6), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_NR_JL::sipChainIkSolverPos_NR_JL(const ChainIkSolverPos_NR_JL& a0): ChainIkSolverPos_NR_JL(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_NR_JL::~sipChainIkSolverPos_NR_JL()
{
    sipCommonDtor(sipPySelf);
}

void sipChainIkSolverPos_NR_JL::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
        ChainIkSolverPos_NR_JL::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_0(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverPos_NR_JL::CartToJnt(const JntArray& a0,const Frame& a1,JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return ChainIkSolverPos_NR_JL::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const JntArray&,const Frame&,JntArray&);

    return sipVH_PyKDL_4(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverPos_NR_JL_CartToJnt, "ChainIkSolverPos_NR_JL.CartToJnt(JntArray, Frame, JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverPos_NR_JL_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_NR_JL_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        const JntArray* a0;
        const Frame* a1;
        JntArray* a2;
        ChainIkSolverPos_NR_JL *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_init,
            sipName_p_in,
            sipName_q_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverPos_NR_JL, &sipCpp, sipType_JntArray, &a0, sipType_Frame, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp->ChainIkSolverPos_NR_JL::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_NR_JL, sipName_CartToJnt, doc_ChainIkSolverPos_NR_JL_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverPos_NR_JL_updateInternalDataStructures, "ChainIkSolverPos_NR_JL.updateInternalDataStructures()");

extern "C" {static PyObject *meth_ChainIkSolverPos_NR_JL_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_NR_JL_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerived((sipSimpleWrapper *)sipSelf));

    {
        ChainIkSolverPos_NR_JL *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverPos_NR_JL, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp->ChainIkSolverPos_NR_JL::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_NR_JL, sipName_updateInternalDataStructures, doc_ChainIkSolverPos_NR_JL_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_ChainIkSolverPos_NR_JL(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverPos_NR_JL(void *ptr, const sipTypeDef *targetType)
{
    void *res;

    if (targetType == sipType_ChainIkSolverPos_NR_JL)
        return ptr;

    if ((res = ((const sipClassTypeDef *)sipType_ChainIkSolverPos)->ctd_cast((ChainIkSolverPos *)(ChainIkSolverPos_NR_JL *)ptr,targetType)) != NULL)
        return res;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverPos_NR_JL(void *, int);}
static void release_ChainIkSolverPos_NR_JL(void *sipCppV,int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverPos_NR_JL *>(sipCppV);
    else
        delete reinterpret_cast<ChainIkSolverPos_NR_JL *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverPos_NR_JL(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverPos_NR_JL(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerived(sipSelf))
        reinterpret_cast<sipChainIkSolverPos_NR_JL *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsPyOwned(sipSelf))
    {
        release_ChainIkSolverPos_NR_JL(sipGetAddress(sipSelf),sipSelf->flags);
    }
}


extern "C" {static void *init_type_ChainIkSolverPos_NR_JL(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverPos_NR_JL(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverPos_NR_JL *sipCpp = 0;

    {
        const Chain* a0;
        const JntArray* a1;
        const JntArray* a2;
        ChainFkSolverPos* a3;
        ChainIkSolverVel* a4;
        uint a5 = 100;
        double a6 = epsilon;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_q_min,
            sipName_q_max,
            sipName_fksolver,
            sipName_iksolver,
            sipName_maxiter,
            sipName_eps,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9J9J9J9|ud", sipType_Chain, &a0, sipType_JntArray, &a1, sipType_JntArray, &a2, sipType_ChainFkSolverPos, &a3, sipType_ChainIkSolverVel, &a4, &a5, &a6))
        {
            sipCpp = new sipChainIkSolverPos_NR_JL(*a0,*a1,*a2,*a3,*a4,a5,a6);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const ChainIkSolverPos_NR_JL* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverPos_NR_JL, &a0))
        {
            sipCpp = new sipChainIkSolverPos_NR_JL(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverPos_NR_JL[] = {{6, 255, 1}};


static PyMethodDef methods_ChainIkSolverPos_NR_JL[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverPos_NR_JL_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_NR_JL_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverPos_NR_JL_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_NR_JL_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverPos_NR_JL, "\1ChainIkSolverPos_NR_JL(Chain, JntArray, JntArray, ChainFkSolverPos, ChainIkSolverVel, int maxiter=100, float eps=epsilon)\n"
    "ChainIkSolverPos_NR_JL(ChainIkSolverPos_NR_JL)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverPos_NR_JL = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverPos_NR_JL,
        {0}
    },
    {
        sipNameNr_ChainIkSolverPos_NR_JL,
        {0, 0, 1},
        2, methods_ChainIkSolverPos_NR_JL,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverPos_NR_JL,
    -1,
    -1,
    supers_ChainIkSolverPos_NR_JL,
    0,
    init_type_ChainIkSolverPos_NR_JL,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverPos_NR_JL,
    0,
    0,
    0,
    release_ChainIkSolverPos_NR_JL,
    cast_ChainIkSolverPos_NR_JL,
    0,
    0,
    0,
    0,
    0,
    0
};
