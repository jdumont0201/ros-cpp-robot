/*
 * Module code.
 *
 * Generated by SIP 4.17
 */

#include "sipAPIPyKDL.h"

#line 172 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 13 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"

#line 21 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 17 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_JntArray_rows, "JntArray.rows() -> int");

extern "C" {static PyObject *meth_JntArray_rows(PyObject *, PyObject *);}
static PyObject *meth_JntArray_rows(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const JntArray *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_JntArray, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->rows();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArray, sipName_rows, doc_JntArray_rows);

    return NULL;
}


PyDoc_STRVAR(doc_JntArray_columns, "JntArray.columns() -> int");

extern "C" {static PyObject *meth_JntArray_columns(PyObject *, PyObject *);}
static PyObject *meth_JntArray_columns(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const JntArray *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_JntArray, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->columns();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArray, sipName_columns, doc_JntArray_columns);

    return NULL;
}


PyDoc_STRVAR(doc_JntArray_resize, "JntArray.resize(int)");

extern "C" {static PyObject *meth_JntArray_resize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_JntArray_resize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
        JntArray *sipCpp;

        static const char *sipKwdList[] = {
            sipName_newSize,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bu", &sipSelf, sipType_JntArray, &sipCpp, &a0))
        {
            sipCpp->resize(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArray, sipName_resize, doc_JntArray_resize);

    return NULL;
}


extern "C" {static PyObject *slot_JntArray___ne__(PyObject *,PyObject *);}
static PyObject *slot_JntArray___ne__(PyObject *sipSelf,PyObject *sipArg)
{
    JntArray *sipCpp = reinterpret_cast<JntArray *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntArray));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const JntArray* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_JntArray, &a0))
        {
            bool sipRes;

            sipRes = !operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL,ne_slot,sipType_JntArray,sipSelf,sipArg);
}


extern "C" {static PyObject *slot_JntArray___eq__(PyObject *,PyObject *);}
static PyObject *slot_JntArray___eq__(PyObject *sipSelf,PyObject *sipArg)
{
    JntArray *sipCpp = reinterpret_cast<JntArray *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntArray));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const JntArray* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_JntArray, &a0))
        {
            bool sipRes;

            sipRes = operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL,eq_slot,sipType_JntArray,sipSelf,sipArg);
}


extern "C" {static PyObject *slot_JntArray___repr__(PyObject *);}
static PyObject *slot_JntArray___repr__(PyObject *sipSelf)
{
    JntArray *sipCpp = reinterpret_cast<JntArray *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntArray));

    if (!sipCpp)
        return 0;


    {
        {
            const std::string*sipRes = 0;

#line 203 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
    std::stringstream ss;
    ss<<sipCpp->data;
    std::string s(ss.str());
    sipRes=&s;
#line 187 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"

            return sipConvertFromType(const_cast<std::string *>(sipRes),sipType_std_string,NULL);
        }
    }

    return 0;
}


extern "C" {static int slot_JntArray___setitem__(PyObject *,PyObject *);}
static int slot_JntArray___setitem__(PyObject *sipSelf,PyObject *sipArgs)
{
    JntArray *sipCpp = reinterpret_cast<JntArray *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntArray));

    if (!sipCpp)
        return -1;

    PyObject *sipParseErr = NULL;

    {
        int a0;
        double a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "id", &a0, &a1))
        {
#line 194 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
    if (a0 < 0 || a0 >= (int)sipCpp->rows()) {
        PyErr_SetString(PyExc_IndexError, "JntArray index out of range");
        return 0;
    }
    (*sipCpp)(a0)=a1;
#line 219 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"

            return 0;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArray, sipName___setitem__, NULL);

    return -1;
}


extern "C" {static PyObject *slot_JntArray___getitem__(PyObject *,PyObject *);}
static PyObject *slot_JntArray___getitem__(PyObject *sipSelf,PyObject *sipArg)
{
    JntArray *sipCpp = reinterpret_cast<JntArray *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntArray));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        int a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &a0))
        {
            double sipRes = 0;

#line 185 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
    if (a0 < 0 || a0 >= (int)sipCpp->rows()) {
        PyErr_SetString(PyExc_IndexError, "JntArray index out of range");
        return 0;
    }
    sipRes=(*sipCpp)(a0);
#line 255 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntArray, sipName___getitem__, NULL);

    return 0;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_JntArray(void *, const sipTypeDef *);}
static void *cast_JntArray(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_JntArray)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_JntArray(void *, int);}
static void release_JntArray(void *sipCppV,int)
{
    delete reinterpret_cast<JntArray *>(sipCppV);
}


extern "C" {static void dealloc_JntArray(sipSimpleWrapper *);}
static void dealloc_JntArray(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_JntArray(sipGetAddress(sipSelf),0);
    }
}


extern "C" {static void *init_type_JntArray(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_JntArray(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    JntArray *sipCpp = 0;

    {
        uint a0;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "u", &a0))
        {
            sipCpp = new JntArray(a0);

            return sipCpp;
        }
    }

    {
        const JntArray* a0;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_JntArray, &a0))
        {
            sipCpp = new JntArray(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_JntArray[] = {
    {(void *)slot_JntArray___ne__, ne_slot},
    {(void *)slot_JntArray___eq__, eq_slot},
    {(void *)slot_JntArray___repr__, repr_slot},
    {(void *)slot_JntArray___setitem__, setitem_slot},
    {(void *)slot_JntArray___getitem__, getitem_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_JntArray[] = {
    {SIP_MLNAME_CAST(sipName_columns), meth_JntArray_columns, METH_VARARGS, SIP_MLDOC_CAST(doc_JntArray_columns)},
    {SIP_MLNAME_CAST(sipName_resize), (PyCFunction)meth_JntArray_resize, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_JntArray_resize)},
    {SIP_MLNAME_CAST(sipName_rows), meth_JntArray_rows, METH_VARARGS, SIP_MLDOC_CAST(doc_JntArray_rows)}
};

PyDoc_STRVAR(doc_JntArray, "\1JntArray(int)\n"
    "JntArray(JntArray)");


sipClassTypeDef sipTypeDef_PyKDL_JntArray = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_JntArray,
        {0}
    },
    {
        sipNameNr_JntArray,
        {0, 0, 1},
        3, methods_JntArray,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_JntArray,
    -1,
    -1,
    0,
    slots_JntArray,
    init_type_JntArray,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_JntArray,
    0,
    0,
    0,
    release_JntArray,
    cast_JntArray,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 153 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/tree.hpp>
using namespace KDL;
#line 409 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"

#line 21 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 413 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"
#line 133 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 417 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"
#line 103 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 422 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_Tree_addSegment, "Tree.addSegment(Segment, string) -> bool");

extern "C" {static PyObject *meth_Tree_addSegment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Tree_addSegment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const Segment* a0;
        const std::string* a1;
        int a1State = 0;
        Tree *sipCpp;

        static const char *sipKwdList[] = {
            sipName_segment,
            sipName_hook_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J1", &sipSelf, sipType_Tree, &sipCpp, sipType_Segment, &a0, sipType_std_string,&a1, &a1State))
        {
            bool sipRes;

            sipRes = sipCpp->addSegment(*a0,*a1);
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_addSegment, doc_Tree_addSegment);

    return NULL;
}


PyDoc_STRVAR(doc_Tree_getNrOfJoints, "Tree.getNrOfJoints() -> int");

extern "C" {static PyObject *meth_Tree_getNrOfJoints(PyObject *, PyObject *);}
static PyObject *meth_Tree_getNrOfJoints(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Tree *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Tree, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfJoints();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_getNrOfJoints, doc_Tree_getNrOfJoints);

    return NULL;
}


PyDoc_STRVAR(doc_Tree_getNrOfSegments, "Tree.getNrOfSegments() -> int");

extern "C" {static PyObject *meth_Tree_getNrOfSegments(PyObject *, PyObject *);}
static PyObject *meth_Tree_getNrOfSegments(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Tree *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Tree, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfSegments();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_getNrOfSegments, doc_Tree_getNrOfSegments);

    return NULL;
}


PyDoc_STRVAR(doc_Tree_getChain, "Tree.getChain(string, string) -> Chain");

extern "C" {static PyObject *meth_Tree_getChain(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Tree_getChain(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string* a0;
        int a0State = 0;
        const std::string* a1;
        int a1State = 0;
        const Tree *sipCpp;

        static const char *sipKwdList[] = {
            sipName_chain_root,
            sipName_chain_tip,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_Tree, &sipCpp, sipType_std_string,&a0, &a0State, sipType_std_string,&a1, &a1State))
        {
            Chain*sipRes = 0;

#line 163 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
    Chain* chain = new Chain();
    sipCpp->getChain(*a0, *a1, *chain);
    sipRes = chain;
#line 542 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            return sipConvertFromType(sipRes,sipType_Chain,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_getChain, doc_Tree_getChain);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_Tree(void *, const sipTypeDef *);}
static void *cast_Tree(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_Tree)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_Tree(void *, int);}
static void release_Tree(void *sipCppV,int)
{
    delete reinterpret_cast<Tree *>(sipCppV);
}


extern "C" {static void assign_Tree(void *, SIP_SSIZE_T, const void *);}
static void assign_Tree(void *sipDst, SIP_SSIZE_T sipDstIdx, const void *sipSrc)
{
    reinterpret_cast<Tree *>(sipDst)[sipDstIdx] = *reinterpret_cast<const Tree *>(sipSrc);
}


extern "C" {static void *array_Tree(SIP_SSIZE_T);}
static void *array_Tree(SIP_SSIZE_T sipNrElem)
{
    return new Tree[sipNrElem];
}


extern "C" {static void *copy_Tree(const void *, SIP_SSIZE_T);}
static void *copy_Tree(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new Tree(reinterpret_cast<const Tree *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Tree(sipSimpleWrapper *);}
static void dealloc_Tree(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_Tree(sipGetAddress(sipSelf),0);
    }
}


extern "C" {static void *init_type_Tree(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Tree(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    Tree *sipCpp = 0;

    {
        const std::string& a0def = "root";
        const std::string* a0 = &a0def;
        int a0State = 0;

        static const char *sipKwdList[] = {
            sipName_root_name,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|J1", sipType_std_string,&a0, &a0State))
        {
            sipCpp = new Tree(*a0);
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipCpp;
        }
    }

    {
        const Tree* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_Tree, &a0))
        {
            sipCpp = new Tree(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_Tree[] = {
    {SIP_MLNAME_CAST(sipName_addSegment), (PyCFunction)meth_Tree_addSegment, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Tree_addSegment)},
    {SIP_MLNAME_CAST(sipName_getChain), (PyCFunction)meth_Tree_getChain, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Tree_getChain)},
    {SIP_MLNAME_CAST(sipName_getNrOfJoints), meth_Tree_getNrOfJoints, METH_VARARGS, SIP_MLDOC_CAST(doc_Tree_getNrOfJoints)},
    {SIP_MLNAME_CAST(sipName_getNrOfSegments), meth_Tree_getNrOfSegments, METH_VARARGS, SIP_MLDOC_CAST(doc_Tree_getNrOfSegments)}
};

PyDoc_STRVAR(doc_Tree, "\1Tree(string root_name=\"root\")\n"
    "Tree(Tree)");


sipClassTypeDef sipTypeDef_PyKDL_Tree = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Tree,
        {0}
    },
    {
        sipNameNr_Tree,
        {0, 0, 1},
        4, methods_Tree,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Tree,
    -1,
    -1,
    0,
    0,
    init_type_Tree,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Tree,
    assign_Tree,
    array_Tree,
    copy_Tree,
    release_Tree,
    cast_Tree,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 133 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 708 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"

#line 103 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 714 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_Chain_addSegment, "Chain.addSegment(Segment)");

extern "C" {static PyObject *meth_Chain_addSegment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Chain_addSegment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const Segment* a0;
        Chain *sipCpp;

        static const char *sipKwdList[] = {
            sipName_segment,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Chain, &sipCpp, sipType_Segment, &a0))
        {
            sipCpp->addSegment(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_addSegment, doc_Chain_addSegment);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_addChain, "Chain.addChain(Chain)");

extern "C" {static PyObject *meth_Chain_addChain(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Chain_addChain(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const Chain* a0;
        Chain *sipCpp;

        static const char *sipKwdList[] = {
            sipName_chain,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Chain, &sipCpp, sipType_Chain, &a0))
        {
            sipCpp->addChain(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_addChain, doc_Chain_addChain);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_getNrOfJoints, "Chain.getNrOfJoints() -> int");

extern "C" {static PyObject *meth_Chain_getNrOfJoints(PyObject *, PyObject *);}
static PyObject *meth_Chain_getNrOfJoints(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Chain *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Chain, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfJoints();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_getNrOfJoints, doc_Chain_getNrOfJoints);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_getNrOfSegments, "Chain.getNrOfSegments() -> int");

extern "C" {static PyObject *meth_Chain_getNrOfSegments(PyObject *, PyObject *);}
static PyObject *meth_Chain_getNrOfSegments(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Chain *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Chain, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfSegments();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_getNrOfSegments, doc_Chain_getNrOfSegments);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_getSegment, "Chain.getSegment(int) -> Segment");

extern "C" {static PyObject *meth_Chain_getSegment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Chain_getSegment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
        const Chain *sipCpp;

        static const char *sipKwdList[] = {
            sipName_nr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bu", &sipSelf, sipType_Chain, &sipCpp, &a0))
        {
            Segment*sipRes;

            sipRes = new Segment(sipCpp->getSegment(a0));

            return sipConvertFromNewType(sipRes,sipType_Segment,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_getSegment, doc_Chain_getSegment);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_Chain(void *, const sipTypeDef *);}
static void *cast_Chain(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_Chain)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_Chain(void *, int);}
static void release_Chain(void *sipCppV,int)
{
    delete reinterpret_cast<Chain *>(sipCppV);
}


extern "C" {static void assign_Chain(void *, SIP_SSIZE_T, const void *);}
static void assign_Chain(void *sipDst, SIP_SSIZE_T sipDstIdx, const void *sipSrc)
{
    reinterpret_cast<Chain *>(sipDst)[sipDstIdx] = *reinterpret_cast<const Chain *>(sipSrc);
}


extern "C" {static void *array_Chain(SIP_SSIZE_T);}
static void *array_Chain(SIP_SSIZE_T sipNrElem)
{
    return new Chain[sipNrElem];
}


extern "C" {static void *copy_Chain(const void *, SIP_SSIZE_T);}
static void *copy_Chain(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new Chain(reinterpret_cast<const Chain *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Chain(sipSimpleWrapper *);}
static void dealloc_Chain(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_Chain(sipGetAddress(sipSelf),0);
    }
}


extern "C" {static void *init_type_Chain(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Chain(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    Chain *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new Chain();

            return sipCpp;
        }
    }

    {
        const Chain* a0;

        static const char *sipKwdList[] = {
            sipName_in,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Chain, &a0))
        {
            sipCpp = new Chain(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_Chain[] = {
    {SIP_MLNAME_CAST(sipName_addChain), (PyCFunction)meth_Chain_addChain, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Chain_addChain)},
    {SIP_MLNAME_CAST(sipName_addSegment), (PyCFunction)meth_Chain_addSegment, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Chain_addSegment)},
    {SIP_MLNAME_CAST(sipName_getNrOfJoints), meth_Chain_getNrOfJoints, METH_VARARGS, SIP_MLDOC_CAST(doc_Chain_getNrOfJoints)},
    {SIP_MLNAME_CAST(sipName_getNrOfSegments), meth_Chain_getNrOfSegments, METH_VARARGS, SIP_MLDOC_CAST(doc_Chain_getNrOfSegments)},
    {SIP_MLNAME_CAST(sipName_getSegment), (PyCFunction)meth_Chain_getSegment, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Chain_getSegment)}
};

PyDoc_STRVAR(doc_Chain, "\1Chain()\n"
    "Chain(Chain)");


sipClassTypeDef sipTypeDef_PyKDL_Chain = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Chain,
        {0}
    },
    {
        sipNameNr_Chain,
        {0, 0, 1},
        5, methods_Chain,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Chain,
    -1,
    -1,
    0,
    0,
    init_type_Chain,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Chain,
    assign_Chain,
    array_Chain,
    copy_Chain,
    release_Chain,
    cast_Chain,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 103 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 1013 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"

#line 21 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 1017 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"
#line 25 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/joint.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 1022 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"
#line 201 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1028 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"
#line 81 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rigidbodyinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 1033 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"
#line 281 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1039 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_Segment_getFrameToTip, "Segment.getFrameToTip() -> Frame");

extern "C" {static PyObject *meth_Segment_getFrameToTip(PyObject *, PyObject *);}
static PyObject *meth_Segment_getFrameToTip(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
            Frame*sipRes;

            sipRes = new Frame(sipCpp->getFrameToTip());

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getFrameToTip, doc_Segment_getFrameToTip);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_pose, "Segment.pose(float) -> Frame");

extern "C" {static PyObject *meth_Segment_pose(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Segment_pose(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        const Segment *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_Segment, &sipCpp, &a0))
        {
            Frame*sipRes;

            sipRes = new Frame(sipCpp->pose(a0));

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_pose, doc_Segment_pose);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_twist, "Segment.twist(float, float) -> Twist");

extern "C" {static PyObject *meth_Segment_twist(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Segment_twist(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        const Segment *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q,
            sipName_qdot,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bdd", &sipSelf, sipType_Segment, &sipCpp, &a0, &a1))
        {
            Twist*sipRes;

            sipRes = new Twist(sipCpp->twist(a0,a1));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_twist, doc_Segment_twist);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_getName, "Segment.getName() -> string");

extern "C" {static PyObject *meth_Segment_getName(PyObject *, PyObject *);}
static PyObject *meth_Segment_getName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
            std::string*sipRes;

            sipRes = new std::string(sipCpp->getName());

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getName, doc_Segment_getName);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_getJoint, "Segment.getJoint() -> Joint");

extern "C" {static PyObject *meth_Segment_getJoint(PyObject *, PyObject *);}
static PyObject *meth_Segment_getJoint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
            Joint*sipRes;

            sipRes = new Joint(sipCpp->getJoint());

            return sipConvertFromNewType(sipRes,sipType_Joint,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getJoint, doc_Segment_getJoint);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_getInertia, "Segment.getInertia() -> RigidBodyInertia");

extern "C" {static PyObject *meth_Segment_getInertia(PyObject *, PyObject *);}
static PyObject *meth_Segment_getInertia(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
            RigidBodyInertia*sipRes;

            sipRes = new RigidBodyInertia(sipCpp->getInertia());

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getInertia, doc_Segment_getInertia);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_setInertia, "Segment.setInertia(RigidBodyInertia)");

extern "C" {static PyObject *meth_Segment_setInertia(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Segment_setInertia(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const RigidBodyInertia* a0;
        Segment *sipCpp;

        static const char *sipKwdList[] = {
            sipName_Iin,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Segment, &sipCpp, sipType_RigidBodyInertia, &a0))
        {
            sipCpp->setInertia(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_setInertia, doc_Segment_setInertia);

    return NULL;
}


extern "C" {static PyObject *slot_Segment___repr__(PyObject *);}
static PyObject *slot_Segment___repr__(PyObject *sipSelf)
{
    Segment *sipCpp = reinterpret_cast<Segment *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Segment));

    if (!sipCpp)
        return 0;


    {
        {
            const std::string*sipRes = 0;

#line 114 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
    std::stringstream ss;
    ss<<(*sipCpp);
    std::string s(ss.str());
    sipRes=&s;
#line 1265 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"

            return sipConvertFromType(const_cast<std::string *>(sipRes),sipType_std_string,NULL);
        }
    }

    return 0;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_Segment(void *, const sipTypeDef *);}
static void *cast_Segment(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_Segment)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_Segment(void *, int);}
static void release_Segment(void *sipCppV,int)
{
    delete reinterpret_cast<Segment *>(sipCppV);
}


extern "C" {static void assign_Segment(void *, SIP_SSIZE_T, const void *);}
static void assign_Segment(void *sipDst, SIP_SSIZE_T sipDstIdx, const void *sipSrc)
{
    reinterpret_cast<Segment *>(sipDst)[sipDstIdx] = *reinterpret_cast<const Segment *>(sipSrc);
}


extern "C" {static void *array_Segment(SIP_SSIZE_T);}
static void *array_Segment(SIP_SSIZE_T sipNrElem)
{
    return new Segment[sipNrElem];
}


extern "C" {static void *copy_Segment(const void *, SIP_SSIZE_T);}
static void *copy_Segment(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new Segment(reinterpret_cast<const Segment *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Segment(sipSimpleWrapper *);}
static void dealloc_Segment(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_Segment(sipGetAddress(sipSelf),0);
    }
}


extern "C" {static void *init_type_Segment(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Segment(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    Segment *sipCpp = 0;

    {
        const std::string* a0;
        int a0State = 0;
        const Joint& a1def = Joint(Joint::None);
        const Joint* a1 = &a1def;
        const Frame& a2def = Frame::Identity();
        const Frame* a2 = &a2def;
        const RigidBodyInertia& a3def = RigidBodyInertia::Zero();
        const RigidBodyInertia* a3 = &a3def;

        static const char *sipKwdList[] = {
            sipName_name,
            sipName_joint,
            sipName_f_tip,
            sipName_I,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1|J9J9J9", sipType_std_string,&a0, &a0State, sipType_Joint, &a1, sipType_Frame, &a2, sipType_RigidBodyInertia, &a3))
        {
            sipCpp = new Segment(*a0,*a1,*a2,*a3);
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipCpp;
        }
    }

    {
        const Joint& a0def = Joint(Joint::None);
        const Joint* a0 = &a0def;
        const Frame& a1def = Frame::Identity();
        const Frame* a1 = &a1def;
        const RigidBodyInertia& a2def = RigidBodyInertia::Zero();
        const RigidBodyInertia* a2 = &a2def;

        static const char *sipKwdList[] = {
            sipName_joint,
            sipName_f_tip,
            sipName_I,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|J9J9J9", sipType_Joint, &a0, sipType_Frame, &a1, sipType_RigidBodyInertia, &a2))
        {
            sipCpp = new Segment(*a0,*a1,*a2);

            return sipCpp;
        }
    }

    {
        const Segment* a0;

        static const char *sipKwdList[] = {
            sipName_in,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Segment, &a0))
        {
            sipCpp = new Segment(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_Segment[] = {
    {(void *)slot_Segment___repr__, repr_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_Segment[] = {
    {SIP_MLNAME_CAST(sipName_getFrameToTip), meth_Segment_getFrameToTip, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getFrameToTip)},
    {SIP_MLNAME_CAST(sipName_getInertia), meth_Segment_getInertia, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getInertia)},
    {SIP_MLNAME_CAST(sipName_getJoint), meth_Segment_getJoint, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getJoint)},
    {SIP_MLNAME_CAST(sipName_getName), meth_Segment_getName, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getName)},
    {SIP_MLNAME_CAST(sipName_pose), (PyCFunction)meth_Segment_pose, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Segment_pose)},
    {SIP_MLNAME_CAST(sipName_setInertia), (PyCFunction)meth_Segment_setInertia, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Segment_setInertia)},
    {SIP_MLNAME_CAST(sipName_twist), (PyCFunction)meth_Segment_twist, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Segment_twist)}
};

PyDoc_STRVAR(doc_Segment, "\1Segment(string, Joint joint=Joint(Joint.None), Frame f_tip=Frame.Identity(), RigidBodyInertia I=RigidBodyInertia.Zero())\n"
    "Segment(Joint joint=Joint(Joint.None), Frame f_tip=Frame.Identity(), RigidBodyInertia I=RigidBodyInertia.Zero())\n"
    "Segment(Segment)");


sipClassTypeDef sipTypeDef_PyKDL_Segment = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Segment,
        {0}
    },
    {
        sipNameNr_Segment,
        {0, 0, 1},
        7, methods_Segment,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Segment,
    -1,
    -1,
    0,
    slots_Segment,
    init_type_Segment,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Segment,
    assign_Segment,
    array_Segment,
    copy_Segment,
    release_Segment,
    cast_Segment,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 81 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rigidbodyinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 1472 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"

#line 26 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1479 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"
#line 64 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rotationalinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 1484 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"
#line 352 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1490 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"
#line 281 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1496 "/home/jbmdumont/catkin_ws/lib/python_orocos_kdl/build/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_RigidBodyInertia_Zero, "RigidBodyInertia.Zero() -> RigidBodyInertia");

extern "C" {static PyObject *meth_RigidBodyInertia_Zero(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_Zero(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            RigidBodyInertia*sipRes;

            sipRes = new RigidBodyInertia(RigidBodyInertia::Zero());

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_Zero, doc_RigidBodyInertia_Zero);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_RefPoint, "RigidBodyInertia.RefPoint(Vector) -> RigidBodyInertia");

extern "C" {static PyObject *meth_RigidBodyInertia_RefPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_RefPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const Vector* a0;
        RigidBodyInertia *sipCpp;

        static const char *sipKwdList[] = {
            sipName_p,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_RigidBodyInertia, &sipCpp, sipType_Vector, &a0))
        {
            RigidBodyInertia*sipRes;

            sipRes = new RigidBodyInertia(sipCpp->RefPoint(*a0));

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_RefPoint, doc_RigidBodyInertia_RefPoint);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_getMass, "RigidBodyInertia.getMass() -> float");

extern "C" {static PyObject *meth_RigidBodyInertia_getMass(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_getMass(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const RigidBodyInertia *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RigidBodyInertia, &sipCpp))
        {
            double sipRes;

            sipRes = sipCpp->getMass();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_getMass, doc_RigidBodyInertia_getMass);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_getCOG, "RigidBodyInertia.getCOG() -> Vector");

extern "C" {static PyObject *meth_RigidBodyInertia_getCOG(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_getCOG(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const RigidBodyInertia *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RigidBodyInertia, &sipCpp))
        {
            Vector*sipRes;

            sipRes = new Vector(sipCpp->getCOG());

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_getCOG, doc_RigidBodyInertia_getCOG);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_getRotationalInertia, "RigidBodyInertia.getRotationalInertia() -> RotationalInertia");

extern "C" {static PyObject *meth_RigidBodyInertia_getRotationalInertia(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_getRotationalInertia(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const RigidBodyInertia *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RigidBodyInertia, &sipCpp))
        {
            RotationalInertia*sipRes;

            sipRes = new RotationalInertia(sipCpp->getRotationalInertia());

            return sipConvertFromNewType(sipRes,sipType_RotationalInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_getRotationalInertia, doc_RigidBodyInertia_getRotationalInertia);

    return NULL;
}


extern "C" {static PyObject *slot_RigidBodyInertia___mul__(PyObject *,PyObject *);}
static PyObject *slot_RigidBodyInertia___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        const RigidBodyInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "dJ9", &a0, sipType_RigidBodyInertia, &a1))
        {
            RigidBodyInertia*sipRes;

            sipRes = new RigidBodyInertia((a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    {
        const RigidBodyInertia* a0;
        const Twist* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RigidBodyInertia, &a0, sipType_Twist, &a1))
        {
            Wrench*sipRes;

            sipRes = new Wrench((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL,mul_slot,NULL,sipArg0,sipArg1);
}


extern "C" {static PyObject *slot_RigidBodyInertia___add__(PyObject *,PyObject *);}
static PyObject *slot_RigidBodyInertia___add__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const RigidBodyInertia* a0;
        const RigidBodyInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RigidBodyInertia, &a0, sipType_RigidBodyInertia, &a1))
        {
            RigidBodyInertia*sipRes;

            sipRes = new RigidBodyInertia((*a0 + *a1));

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL,add_slot,NULL,sipArg0,sipArg1);
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_RigidBodyInertia(void *, const sipTypeDef *);}
static void *cast_RigidBodyInertia(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_RigidBodyInertia)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_RigidBodyInertia(void *, int);}
static void release_RigidBodyInertia(void *sipCppV,int)
{
    delete reinterpret_cast<RigidBodyInertia *>(sipCppV);
}


extern "C" {static void assign_RigidBodyInertia(void *, SIP_SSIZE_T, const void *);}
static void assign_RigidBodyInertia(void *sipDst, SIP_SSIZE_T sipDstIdx, const void *sipSrc)
{
    reinterpret_cast<RigidBodyInertia *>(sipDst)[sipDstIdx] = *reinterpret_cast<const RigidBodyInertia *>(sipSrc);
}


extern "C" {static void *array_RigidBodyInertia(SIP_SSIZE_T);}
static void *array_RigidBodyInertia(SIP_SSIZE_T sipNrElem)
{
    return new RigidBodyInertia[sipNrElem];
}


extern "C" {static void *copy_RigidBodyInertia(const void *, SIP_SSIZE_T);}
static void *copy_RigidBodyInertia(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new RigidBodyInertia(reinterpret_cast<const RigidBodyInertia *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_RigidBodyInertia(sipSimpleWrapper *);}
static void dealloc_RigidBodyInertia(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_RigidBodyInertia(sipGetAddress(sipSelf),0);
    }
}


extern "C" {static void *init_type_RigidBodyInertia(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_RigidBodyInertia(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    RigidBodyInertia *sipCpp = 0;

    {
        double a0 = 0;
        const Vector& a1def = Vector::Zero();
        const Vector* a1 = &a1def;
        const RotationalInertia& a2def = RotationalInertia::Zero();
        const RotationalInertia* a2 = &a2def;

        static const char *sipKwdList[] = {
            sipName_m,
            sipName_oc,
            sipName_Ic,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|dJ9J9", &a0, sipType_Vector, &a1, sipType_RotationalInertia, &a2))
        {
            sipCpp = new RigidBodyInertia(a0,*a1,*a2);

            return sipCpp;
        }
    }

    {
        const RigidBodyInertia* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_RigidBodyInertia, &a0))
        {
            sipCpp = new RigidBodyInertia(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_RigidBodyInertia[] = {
    {(void *)slot_RigidBodyInertia___mul__, mul_slot},
    {(void *)slot_RigidBodyInertia___add__, add_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_RigidBodyInertia[] = {
    {SIP_MLNAME_CAST(sipName_RefPoint), (PyCFunction)meth_RigidBodyInertia_RefPoint, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_RigidBodyInertia_RefPoint)},
    {SIP_MLNAME_CAST(sipName_Zero), meth_RigidBodyInertia_Zero, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_Zero)},
    {SIP_MLNAME_CAST(sipName_getCOG), meth_RigidBodyInertia_getCOG, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_getCOG)},
    {SIP_MLNAME_CAST(sipName_getMass), meth_RigidBodyInertia_getMass, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_getMass)},
    {SIP_MLNAME_CAST(sipName_getRotationalInertia), meth_RigidBodyInertia_getRotationalInertia, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_getRotationalInertia)}
};

PyDoc_STRVAR(doc_RigidBodyInertia, "\1RigidBodyInertia(float m=0, Vector oc=Vector.Zero(), RotationalInertia Ic=RotationalInertia.Zero())\n"
    "RigidBodyInertia(RigidBodyInertia)");


sipClassTypeDef sipTypeDef_PyKDL_RigidBodyInertia = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_RigidBodyInertia,
        {0}
    },
    {
        sipNameNr_RigidBodyInertia,
        {0, 0, 1},
        5, methods_RigidBodyInertia,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_RigidBodyInertia,
    -1,
    -1,
    0,
    slots_RigidBodyInertia,
    init_type_RigidBodyInertia,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_RigidBodyInertia,
    assign_RigidBodyInertia,
    array_RigidBodyInertia,
    copy_RigidBodyInertia,
    release_RigidBodyInertia,
    cast_RigidBodyInertia,
    0,
    0,
    0,
    0,
    0,
    0
};
